/*Copyright Tim Fleming, Crawford Currie 2014-2025. This file is part of SVGcut, see the copyright and LICENSE at the root of the distribution. */

//import "file-saver"
/* global saveAs */

// import "knockout"
/* global ko */

/* global App */

import { UnitConverter } from "./UnitConverter.js";
import * as Gcode from "./Gcode.js";
import { CutPath } from "./CutPath.js";
import { CutPaths } from "./CutPaths.js";
import { ViewModel } from "./ViewModel.js";
import * as Cam from "./Cam.js";
import { Rect } from "./Rect.js";

const DEFAULT_UNITS = "mm";
const DEFAULT_ORIGIN = "SVG page";
const DEFAULT_EXTRAOFFSETX = 0;
const DEFAULT_EXTRAOFFSETY = 0;
const DEFAULT_RETURNTO00 = false;
const DEFAULT_GCODEFILENAME = "svgcut.nc";

/**
 * ViewModel for Gcode Generation panel.
 * @listens UPDATE_GCODE triggers Gcode generation
 */
class GcodeGenerationViewModel extends ViewModel {

  /**
   * Note that this view model has it's own unit converter.
   * The gcode generation will generate gcode coordinates in these
   * units. It will also display generation characteristics,
   * such as offsets, in these units.
   */
  constructor() {
    super();

    document.addEventListener("UPDATE_GCODE", () => this.generateGcode());

    /**
     * Units used in the Gcode pane, and the generated Gcode
     * @member {observable.<string>}
     */
    this.units = ko.observable(DEFAULT_UNITS);

    this.unitConverter = new UnitConverter(this.units);

    /**
     * Flag to lock out gcode generation.
     * @member {boolean}
     */
    this.disable = false;

    /**
     * Gcode generated by this converter
     * @member {observable.<string>}
     */
    this.gcode = ko.observable([]);
    this.gcodeS = ko.observable("");
    this.gcode.subscribe(() => this.gcodeS(this.gcode().join("\n")));

    /**
     * Filename to store gcode in
     * @member {observable.<string>}
     */
    this.gcodeFilename = ko.observable(DEFAULT_GCODEFILENAME);

    /**
     * True to return to machine 0,0 at the end of the GCode.
     * @member {observable.<boolean>}
     */
    this.returnTo00 = ko.observable(DEFAULT_RETURNTO00);
    this.returnTo00.subscribe(() => {
      document.dispatchEvent(new Event("UPDATE_GCODE"));
      document.dispatchEvent(new Event("PROJECT_CHANGED"));
    });

    /**
     * Where the origin is one of "SVG page", "Bounding box" or
     * "Centre".
     * In SVG, the origin is at the top left, and Y increases
     * downwards. Internally we use internal coordinates, which follow
     * this pattern. Gcode, on the other hand, assumes Y increases
     * upwards. "SVG page" will align the machine origin with the lower
     * left corner of the SVG page. "Bounding box" will align with the
     * lower left corner of the work bounding box. "Centre" will align
     * with the centre of the work bounding box.
     * @member {observable.<string>}
     */
    this.origin = ko.observable(DEFAULT_ORIGIN);
    this.origin.subscribe(() => {
      document.dispatchEvent(new Event("UPDATE_GCODE"));
      document.dispatchEvent(new Event("PROJECT_CHANGED"));
    });

    /**
     * Extra offset of the work origin from the machine origin
     * @member{observable.number}
     */
    this.extraOffsetX = ko.observable(DEFAULT_EXTRAOFFSETX);
    this.extraOffsetX.subscribe(() => {
      document.dispatchEvent(new Event("UPDATE_GCODE"));
      document.dispatchEvent(new Event("PROJECT_CHANGED"));
    });
    /* @todo generate G10,G54 to do this
     * For future reference:
     * G10 defines the coordinates of work offsets G54-G59
     * G10 Pn Xxxx Yxxx Zzzz
     * P1=G54.. P6=G59
     * G54..G59 are 6 possible "blank locations" - offsets for
     * workpieces on the platform, referred to as "datums".
     * Switch the datum using "G54".
     * So to set a new zero point at (7, 12):
     * G10 P1 X7 Y12 Z0
     * G54
     */

    /**
     * Extra offset of the work origin from the machine origin
     * @member{observable.number}
     */
    this.extraOffsetY = ko.observable(DEFAULT_EXTRAOFFSETY);
    this.extraOffsetY.subscribe(() => {
      document.dispatchEvent(new Event("UPDATE_GCODE"));
      document.dispatchEvent(new Event("PROJECT_CHANGED"));
    });

    /**
     * Width of the work BB, irrespective of the origin.
     * @member {observable.<number>}
     */
    this.bbWidth = ko.observable(0);

    /**
     * Height of the work BB, irrespective of the origin
     * @member {observable.<number>}
     */
    this.bbHeight = ko.observable(0);

    App.models.Operations.boundingBox.subscribe(
      bb => {
        this.bbWidth(
          this.unitConverter.fromUnits(bb.width, "integer").toFixed(2));
        this.bbHeight(
          this.unitConverter.fromUnits(bb.height, "integer").toFixed(2));
      });
  }

  /**
   * @override
   */
  bind() {  
    for (const id of [
      "GcodeGenerationView", "SaveGcodeModal", "ViewGcodeModal",
      "SimulatePanel" ])
      super.bind(id);
  }

  /**
   * @override
   */
  reset() {
    this.units(DEFAULT_UNITS);
    this.origin(DEFAULT_ORIGIN);
    this.extraOffsetX(DEFAULT_EXTRAOFFSETX);
    this.extraOffsetY(DEFAULT_EXTRAOFFSETY);
    this.returnTo00(DEFAULT_RETURNTO00);
    this.gcode([]);
    this.gcodeFilename(DEFAULT_GCODEFILENAME);
    document.dispatchEvent(new Event("UPDATE_SIMULATION"));
  }

  /**
   * Get the main SVG area in gcode units
   * @return {Rect} a standard left, top, width, height rect
   */
  getSVGBB() {
    const pxBB = App.getMainSVGBBox();
    const gcodeBB = new Rect(
      this.unitConverter.fromUnits(pxBB.x, "px"),
      this.unitConverter.fromUnits(pxBB.y, "px"),
      this.unitConverter.fromUnits(pxBB.width, "px"),
      this.unitConverter.fromUnits(pxBB.height, "px")
    );
    return gcodeBB;
  }

  /**
   * Generate gcode for the tool paths specified by the selected
   * operations in the Operations card. This will be invoked in
   * response to something raising the UPDATE_GCODE event.
   * @private
   */
  generateGcode() {
    if (this.disable)
      return;

    // Get the set of enabled operations
    const ops = [];
    for (const op of App.models.Operations.operations()) {
      if (op.enabled()) {
        if (op.toolPaths() && op.toolPaths().length > 0)
          ops.push(op);
      }
    }
    if (ops.length === 0)
      return;

    console.debug(`generateGcode for ${ops.length} operations`);

    const gunits = this.unitConverter.units();

    // Get enabled tabs
    let tabGeometry = new CutPaths();
    const tabs = App.models.Tabs.tabs();
    const tabsDepth = App.models.Tabs.maxCutDepth.toUnits(gunits);
    for (const tab of tabs) {
      if (tab.enabled()) {
        // Bloat tab geometry by the cutter radius
        const bloat = App.models.Tool.diameter.toUnits("integer") / 2;
        const tg = tab.combinedGeometry.offset(bloat);
        tabGeometry = tabGeometry.union(tg);
      }
    }

    // Work out origin offset
    const svgBB = this.getSVGBB();
    let offsetX = svgBB.left + this.extraOffsetX();
    let offsetY = svgBB.bottom + this.extraOffsetY();
    if (this.origin() === "Bounding box" || this.origin() === "Centre") {
      const pathsBB = this.unitConverter.fromUnits(
        App.models.Operations.getBounds(), "integer");
      offsetX -= pathsBB.left - svgBB.left;
      offsetY -= svgBB.bottom - pathsBB.bottom;
      if (this.origin() === "Centre") {
        offsetX -= pathsBB.width / 2;
        offsetY -= pathsBB.height / 2;
      }
    }

    const job = new Gcode.Generator({
      gunits:         gunits,
      // Scaling to apply to internal units in paths, to generate Gcode units.
      xScale:         UnitConverter.from.integer.to[gunits],
      yScale:         -UnitConverter.from.integer.to[gunits],
      zScale:         1,
      decimal:        2, // 100th mm
      topZ:           App.models.Material.topZ.toUnits(gunits),
      botZ:           App.models.Material.botZ.toUnits(gunits),
      safeZ:          App.models.Material.zSafeMove.toUnits(gunits),
      passDepth:      App.models.Tool.passDepth.toUnits(gunits),
      plungeFeed:     App.models.Tool.plungeRate.toUnits(gunits),
      retractFeed:    App.models.Tool.rapidRate.toUnits(gunits),
      cutFeed:        App.models.Tool.cutRate.toUnits(gunits),
      rapidFeed:      App.models.Tool.rapidRate.toUnits(gunits),
      returnTo00:     this.returnTo00(),
      workWidth:      Number(this.bbWidth()),
      workHeight:     Number(this.bbHeight()),
      offsetX:        offsetX,
      offsetY:        offsetY
    });

    if (job.passDepth < 0) {
      App.showAlert("passDepthTooSmall", "alert-warning", job.passDepth);
      // Plough on; we might be behaving as a plotter
      job.passDepth = 0;
    }

    for (const op of ops) {
      const opCard = {
        name: op.name(),
        cutType: op.operation(),
        ramp: op.ramp(),
        direction: op.direction(),
        spinSpeed: Number(op.spindleSpeed())
      };
      const precalculatedZ = op.operation() === Cam.OP.Perforate
            || op.operation() === Cam.OP.Drill;

      let paths = op.toolPaths();
      const cutZ = job.topZ - Number(op.cutDepth());
      const tabZ = job.topZ - tabsDepth;

      // tabZ must be > the cutZ depth of the Operation. If it isn't,
      // or Z's were precalculated, then ignore the tab geometry
      let tg = (tabZ <= cutZ || precalculatedZ) ? undefined : tabGeometry;

      // Split paths over tab geometry and assign Z's where not
      // already defined in Cam.
      let cutPaths = new CutPaths();
      for (const path of paths) {
        cutPaths = cutPaths.concat(
          Cam.splitPathOverTabs(path, tg, cutZ, tabZ));
      }
      opCard.paths = cutPaths;

      job.addOperation(opCard);
    }

    // Save the gcode to the observable
    this.gcode(job.end());

    console.debug(`${this.gcode().length} lines of Gcode generated`);

    document.dispatchEvent(new Event("UPDATE_SIMULATION"));

    App.tutorial(4);
  }

  haveGcode() {
    const gc = this.gcode();
    return gc && gc.length > 0;
  }

  viewGcode() {
    App.showModal('ViewGcodeModal');
  }

  /**
   * Support for storing gcode in local files.
   * Saves the gcode and hides the modal that invoked the function.
   */
  saveGcodeInFile() {
    App.hideModals();

    if (!this.haveGcode())
      return;

    const gcode = this.gcode().join("\n");
    const blob = new Blob([gcode], {type: 'text/plain'});
    saveAs(blob, this.gcodeFilename());
  }

  /**
   * @override
   */
  jsonFieldName() { return 'gcodeConversion'; }

  /**
   * @override
   */
  toJson() {
    return {
      units: this.unitConverter.units(),
      gcodeFilename: this.gcodeFilename(),
      origin: this.origin(),
      returnTo00: this.returnTo00(),
      extraOffsetX: this.extraOffsetX(),
      extraOffsetY: this.extraOffsetY()
    };
  }

  /**
   * @override
   */
  fromJson(json) {
    this.updateObservable(json, 'units');
    this.updateObservable(json, 'gcodeFilename');
    this.updateObservable(json, 'origin');
    this.updateObservable(json, 'returnTo00');
    this.updateObservable(json, 'extraOffsetX');
    this.updateObservable(json, 'extraOffsetY');
  };
}

export { GcodeGenerationViewModel }
